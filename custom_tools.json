{
  "tools": [
    {
      "name": "read_service_cart",
      "description": "Lee el estado actual del carrito de servicios del usuario para mantener contexto",
      "code": "const readServiceCart = async (conversationId) => {\n  try {\n    // Obtener desde Flow State o API externa\n    const response = await fetch(`${process.env.CASALIMPIA_API_BASE}/cart/${conversationId}`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${process.env.CASALIMPIA_API_TOKEN}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    if (!response.ok) {\n      return JSON.stringify({ \n        cart_items: [], \n        user_city: \"\", \n        total_items: 0,\n        message: \"Carrito vacío\" \n      });\n    }\n    \n    const cartData = await response.json();\n    return JSON.stringify(cartData);\n  } catch (error) {\n    console.error('Error reading cart:', error);\n    return JSON.stringify({ \n      error: 'Failed to read cart', \n      cart_items: [], \n      user_city: \"\",\n      total_items: 0\n    });\n  }\n};",
      "schema": {
        "type": "object",
        "properties": {
          "conversation_id": {
            "type": "string",
            "description": "ID de la conversación actual para identificar el carrito"
          }
        },
        "required": ["conversation_id"]
      }
    },
    {
      "name": "get_services",
      "description": "Obtiene los servicios disponibles para una ciudad específica, con opción de incluir precios",
      "code": "const getServices = async (city, includePrices = false) => {\n  try {\n    // Validar ciudades soportadas\n    const validCities = ['BOGOTA', 'MEDELLIN', 'CALI', 'BARRANQUILLA', 'BUCARAMANGA', 'BOYACA', 'PEREIRA', 'VILLAVICENCIO', 'IBAGUE', 'CARTAGENA', 'CHIA', 'COTA', 'CAJICA', 'PALMIRA', 'JAMUNDI', 'SANTA_MARTA'];\n    \n    if (!validCities.includes(city.toUpperCase())) {\n      return JSON.stringify({\n        error: 'Ciudad no soportada',\n        supported_cities: validCities,\n        message: `Lo siento, actualmente no tenemos cobertura en ${city}. Nuestros servicios están disponibles en: ${validCities.join(', ')}`\n      });\n    }\n    \n    const response = await fetch(`${process.env.CASALIMPIA_API_BASE}/services`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.CASALIMPIA_API_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        ciudad: city.toUpperCase(),\n        include_prices: includePrices\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API Error: ${response.status}`);\n    }\n    \n    const services = await response.json();\n    \n    // Filtrar servicios disponibles y ocultar campos internos\n    const filteredServices = services\n      .filter(service => service['sell-web'] === 1)\n      .map(service => {\n        const { sku, ...serviceWithoutSku } = service;\n        return {\n          ...serviceWithoutSku,\n          _internal_sku: sku // Mantener para uso interno pero oculto\n        };\n      });\n    \n    return JSON.stringify({\n      city: city.toUpperCase(),\n      services: filteredServices,\n      total_services: filteredServices.length\n    });\n  } catch (error) {\n    console.error('Error getting services:', error);\n    return JSON.stringify({ \n      error: 'Failed to get services',\n      city: city,\n      services: [],\n      message: 'Error al obtener servicios. Intenta nuevamente.'\n    });\n  }\n};",
      "schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "description": "Ciudad para consultar servicios disponibles"
          },
          "include_prices": {
            "type": "boolean",
            "description": "Incluir precios en la respuesta para consultas de precios",
            "default": false
          }
        },
        "required": ["city"]
      }
    },
    {
      "name": "get_sic_experts_list",
      "description": "Obtiene la lista de expertas disponibles para un servicio en fecha específica. NUNCA llamar sin fecha confirmada por usuario",
      "code": "const getSicExpertsList = async (city, date, serviceType, serviceSku) => {\n  try {\n    // Validar que se proporcione fecha\n    if (!date) {\n      return JSON.stringify({\n        error: 'Fecha requerida',\n        message: 'No se puede consultar expertas sin fecha específica'\n      });\n    }\n    \n    const response = await fetch(`${process.env.CASALIMPIA_API_BASE}/experts`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.CASALIMPIA_API_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        ciudad: city.toUpperCase(),\n        fecha: date,\n        tipo_servicio: serviceType,\n        sku: serviceSku\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API Error: ${response.status}`);\n    }\n    \n    const experts = await response.json();\n    \n    // Filtrar campos sensibles y formatear respuesta\n    const filteredExperts = experts.map((expert, index) => {\n      const { cedula, Cédula, ...expertWithoutCedula } = expert;\n      return {\n        id: index + 1,\n        ...expertWithoutCedula,\n        _internal_cedula: cedula || Cédula // Mantener para uso interno\n      };\n    });\n    \n    return JSON.stringify({\n      city: city,\n      date: date,\n      service_type: serviceType,\n      experts: filteredExperts,\n      total_experts: filteredExperts.length\n    });\n  } catch (error) {\n    console.error('Error getting experts:', error);\n    return JSON.stringify({ \n      error: 'Failed to get experts',\n      experts: [],\n      message: 'Error al obtener expertas disponibles'\n    });\n  }\n};",
      "schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "description": "Ciudad donde se requiere el servicio"
          },
          "date": {
            "type": "string",
            "description": "Fecha del servicio en formato válido (CRITICAL: usuario debe confirmar fecha explícitamente)"
          },
          "service_type": {
            "type": "string",
            "description": "Tipo de servicio seleccionado"
          },
          "service_sku": {
            "type": "string",
            "description": "SKU del servicio para consultar expertas"
          }
        },
        "required": ["city", "date", "service_type"]
      }
    },
    {
      "name": "create_service_cart_item",
      "description": "Agrega un servicio al carrito con todos los datos confirmados por el usuario",
      "code": "const createServiceCartItem = async (conversationId, sku, nombre, cedula, fechaServicio, ciudadServicio, jornadaServicio) => {\n  try {\n    const response = await fetch(`${process.env.CASALIMPIA_API_BASE}/cart/add`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.CASALIMPIA_API_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        conversation_id: conversationId,\n        sku: sku,\n        nombre: nombre,\n        cedula: cedula,\n        fecha_servicio: fechaServicio,\n        ciudad_servicio: ciudadServicio.toUpperCase(),\n        jornada_servicio: jornadaServicio\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API Error: ${response.status}`);\n    }\n    \n    const result = await response.json();\n    \n    return JSON.stringify({\n      success: true,\n      message: 'Servicio agregado al carrito exitosamente',\n      cart_item: {\n        service: nombre,\n        date: fechaServicio,\n        city: ciudadServicio,\n        expert: 'Seleccionada'\n      },\n      ...result\n    });\n  } catch (error) {\n    console.error('Error creating cart item:', error);\n    return JSON.stringify({ \n      success: false,\n      error: 'Failed to add service to cart',\n      message: 'Error al agregar servicio al carrito. Intenta nuevamente.'\n    });\n  }\n};",
      "schema": {
        "type": "object",
        "properties": {
          "conversation_id": {
            "type": "string",
            "description": "ID de la conversación"
          },
          "sku": {
            "type": "string",
            "description": "SKU del servicio seleccionado"
          },
          "nombre": {
            "type": "string",
            "description": "Nombre de la experta seleccionada"
          },
          "cedula": {
            "type": "string",
            "description": "Cédula de la experta (uso interno)"
          },
          "fecha_servicio": {
            "type": "string",
            "description": "Fecha confirmada del servicio"
          },
          "ciudad_servicio": {
            "type": "string",
            "description": "Ciudad confirmada del servicio"
          },
          "jornada_servicio": {
            "type": "string",
            "description": "Jornada/horario del servicio"
          }
        },
        "required": ["conversation_id", "sku", "nombre", "cedula", "fecha_servicio", "ciudad_servicio", "jornada_servicio"]
      }
    },
    {
      "name": "generate_payment_link",
      "description": "Genera el enlace de pago para los servicios en el carrito",
      "code": "const generatePaymentLink = async (conversationId, userEmail) => {\n  try {\n    // Validar formato de email\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(userEmail)) {\n      return JSON.stringify({\n        success: false,\n        error: 'Invalid email format',\n        message: 'Por favor proporciona un email válido'\n      });\n    }\n    \n    const response = await fetch(`${process.env.CASALIMPIA_API_BASE}/payment/generate`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${process.env.CASALIMPIA_API_TOKEN}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        conversation_id: conversationId,\n        user_email: userEmail\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API Error: ${response.status}`);\n    }\n    \n    const paymentData = await response.json();\n    \n    return JSON.stringify({\n      success: true,\n      payment_link: paymentData.payment_url,\n      total_amount: paymentData.total,\n      services_count: paymentData.services_count,\n      message: '¡Perfecto! He generado tu enlace de pago. Puedes completar la compra de forma segura.'\n    });\n  } catch (error) {\n    console.error('Error generating payment link:', error);\n    return JSON.stringify({ \n      success: false,\n      error: 'Failed to generate payment link',\n      message: 'Error al generar enlace de pago. Intenta nuevamente.'\n    });\n  }\n};",
      "schema": {
        "type": "object",
        "properties": {
          "conversation_id": {
            "type": "string",
            "description": "ID de la conversación"
          },
          "user_email": {
            "type": "string",
            "description": "Email del usuario para el proceso de pago"
          }
        },
        "required": ["conversation_id", "user_email"]
      }
    }
  ]
}